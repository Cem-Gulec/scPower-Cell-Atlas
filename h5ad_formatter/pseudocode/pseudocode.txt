Pseudocode:
-----------
* > dimnames(count.matrix.example[["complete"]])
* > Matrix.matrix
* > cellTypes <- levels(wholeDataset@meta.data$cell_type)
* > wholeDataset['ENSG00000238009',wholeDataset@meta.data$Annotation=='pDC']
* > wholeDataset[,wholeDataset@meta.data$Annotation=='pDC']
* > memory.limit(56000)
* > tissueNames   <- levels(splittedByAssayID[[assayNames[[1]]]]@meta.data$tissue_ontology_term_id)
* > names <- list(assayNames[[1]], tissueNames[[1]], cellTypeNames[[1]], x)
    deneme[[length(deneme)+1]] <- list(names)

Dataset: https://cellxgene.cziscience.com/collections/eb735cc9-d0a7-48fa-b255-db726bf365af

library(Seurat)
library(SeuratData)
library(SeuratDisk)
library(DropletUtils)
library(scuttle)

source("R/datasets.R")
source("R/em.R")
source("R/expression_fit.R")
source("R/plotting.R")
source("R/power.R")
source("R/priors.R")


1. Converting from AnnData to Seurat via h5Seurat
   Convert("autoimmunityPBMCs_blood_covid_1_homosap_97499.h5ad", dest = "h5seurat", overwrite = TRUE)


2. Reading the data in seurat format
   wholeDataset <- LoadH5Seurat("data/autoimmunityPBMCs_blood_covid_1_homosap_97499.h5seurat", assays = "RNA")


3. Splitting dataset into parts by each cell type
   splittedByCellType <- SplitObject(wholeDataset, split.by = "cell_type_ontology_term_id")


4. Extracting count info only 
   countsByCellType <- list()
   cellTypeNames <- names(splittedByCellType) 
   
   for(cellType in splittedByCellType){
      count <- cellType@assays$RNA@counts
      countsByCellType <- append(countsByCellType, count)
   } 


5. Function for conversion from dgCMatrix (sparse matrix) to list
   sparseToList <- function(counts){

     tmp <- matrix(data=0L, nrow = counts@Dim[1], ncol = counts@Dim[2])
     
     row_pos <- counts@i+1
     col_pos <- findInterval(seq(counts@x)-1,counts@p[-1])+1
     val <- counts@x
       
     for (i in seq_along(val)){
         tmp[row_pos[i],col_pos[i]] <- val[i]
     }
       
     row.names(tmp) <- counts@Dimnames[[1]]
     colnames(tmp) <- counts@Dimnames[[2]]
     return(tmp)
   }


6. Tam da buraya gönderilen count matrixi subsample edecek 
   ve complete de eklenmiş bir şekilde tüm listeyi dönecek fonksiyon

   subsampleIntoList <- function(countsAsDGC){
      tmp <- list()
      countsAsList <- sparseToList(countsAsDGC)
      tmp[[length(tmp)+1]] <- countsAsList

      for(s in c(0.75,0.5,0.25)){
         counts.subsampled <- downsampleMatrix(countsAsList, prop = s, bycol = TRUE)
         counts.subsampled <- sparseToList(counts.subsampled)
         tmp[[length(tmp)+1]] <- counts.subsampled
      }      

      tmp <- setNames(tmp, c("complete", "subsampled75", "subsampled50", "subsampled25"))

      return(tmp)
   }

   
7. Iterate over each cell type to acquire 

   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



8. deneme <- subsampleIntoList(countsByCellType[[1]])
   sapply(deneme,dim)


9. Counting observed expressed genes

   expressed.genes.df<-NULL

   #Iterate over each count matrix
   for(name in names(deneme)){
       count.matrix<-deneme[[name]]

       #Create an annotation file (here containing only one cell type, but can be more)
       annot.df<-data.frame(individual=paste0("S",rep(1:14,length.out=ncol(count.matrix))),
                            cell.type=rep("default_ct",ncol(count.matrix)))

       #Reformat count matrix into pseudobulk matrix
       pseudo.bulk<-create.pseudobulk(count.matrix,annot.df)

       #Calculate expressed genes in the pseudobulk matrix
       expressed.genes<-calculate.gene.counts(pseudo.bulk,min.counts=3, perc.indiv=0.5)

       #Get the number of expressed genes
       num.expressed.genes<-nrow(expressed.genes)

       #Save expressed genes
       expressed.genes.df<-rbind(expressed.genes.df,
                                 data.frame(matrix=name,
                                            num.cells=ncol(count.matrix),
                                            expressed.genes=num.expressed.genes))
   }
   print(expressed.genes.df)


10. Estimation of negative binomial paramters for each gene

   norm.mean.values<-NULL
   disp.param<-NULL

   for(name in names(deneme)){
      temp<-nbinom.estimation(deneme[[name]], sizeFactorMethod="poscounts")

      #Save the normalized mean values
      norm.mean.values.temp<-temp[[1]]
      norm.mean.values.temp$matrix<-name
      norm.mean.values<-rbind(norm.mean.values,norm.mean.values.temp)

      #Save the parameter of the mean-dispersion function
      disp.param.temp<-temp[[3]]
      disp.param.temp$matrix<-name
      disp.param<-rbind(disp.param,disp.param.temp)
   }

   #First rows of the data frame with normalized mean values
   head(norm.mean.values)

   #Parameter of the mean - dispersion function
   print(disp.param)


11. Estimation of a gamma mixed distribution over all means
   
   gamma.fits<-NULL
   for(name in names(deneme)){

      #Number of cells per cell type as censoring point
      censoredPoint<- 1 / ncol(deneme[[name]])

      norm.mean.values.temp<-norm.mean.values[norm.mean.values$matrix==name,]
      gamma.fit.temp<-mixed.gamma.estimation(norm.mean.values.temp$mean,
                                             num.genes.kept = 21000,
                                             censoredPoint = censoredPoint)
      gamma.fit.temp$matrix<-name
      gamma.fits<-rbind(gamma.fits,gamma.fit.temp)
   }

   print(gamma.fits)


12. Comparison of gamma mixed fits with original means with visuals
   g<-visualize.gamma.fits(norm.mean.values$mean[norm.mean.values$matrix=="complete"],
                           gamma.fits[gamma.fits$matrix=="complete",],
                           nGenes=21000)
   print(g)


13. Parameterization of the parameters of the gamma fits by the mean UMI counts per cell
   
   #Estimate the mean umi values per cell for each matrix
   umi.values<-NULL

   for(name in names(deneme)){
      mean.umi<-meanUMI.calculation(deneme[[name]])
      umi.values<-rbind(umi.values,data.frame(mean.umi,matrix=name))
   }

   print(umi.values)

   gamma.fits<-merge(gamma.fits,umi.values,by="matrix")

   #Convert the gamma fits from the shape-rate parametrization to the mean-sd parametrization
   gamma.fits<-convert.gamma.parameters(gamma.fits)

   #Visualize the linear relationship between gamma parameters and UMI values in plots
   plot.values<-melt(gamma.fits,id.vars=c("matrix","mean.umi"))
   plot.values<-plot.values[plot.values$variable %in% c("mean1","mean2","sd1","sd2","p1","p2"),]
   ggplot(plot.values,aes(x=mean.umi,y=value))+
      geom_point()+geom_line()+
      facet_wrap(~variable,ncol=2,scales="free")

   #Fit relationship between gamma parameters and UMI values
   gamma.linear.fit.new<-umi.gamma.relation(gamma.fits)
   print(gamma.linear.fit.new)

pre14. 
   
   disp.fun.general.new<-dispersion.function.estimation(disp.param)
   print(disp.fun.general.new)

   gamma.linear.fit.new$ct<-"CD16_"
   disp.fun.general.new$ct<-"New_ct"

   #Number of mapped reads taken from cellranger summary statistics
   mapped.reads<-data.frame(matrix=c("complete","subsampled75","subsampled50","subsampled25"),
                            transcriptome.mapped.reads=c(23130,17422,11666,5859))
   #Plot relationship between mean reads per cell and mean UMI per cell
   read.umis<-merge(umi.values,mapped.reads,by="matrix")
   print(read.umis)

14. Validation of expression probability model
      
   #Merge the observed numbers of expressed genes with the read depth
   expressed.genes.df<-merge(expressed.genes.df,mapped.reads,
   by="matrix")
   #Get the number of cells per cell type and individual
   expressed.genes.df$cells.indiv<-expressed.genes.df$num.cells/14
   expressed.genes.df$estimated.genes<-NA
   for(i in 1:nrow(expressed.genes.df)){
   
      #Vector with the expression probability for each gene
      expr.prob<-estimate.exp.prob.param(nSamples=22,
                                         readDepth=expressed.genes.df$
                                         transcriptome.mapped.reads[i],
                                         nCellsCt=expressed.genes.df$cells.indiv[i],
                                         read.umi.fit = read.umi.fit.new,
                                         gamma.mixed.fits = gamma.linear.fit.new,
                                         ct="CD16-negative",
                                         disp.fun.param=disp.fun.general.new,
                                         min.counts = 3,
                                         perc.indiv = 0.5)
      #Expected number of expressed genes
      expressed.genes.df$estimated.genes[i]<-round(sum(expr.prob))
   }
   print(expressed.genes.df)